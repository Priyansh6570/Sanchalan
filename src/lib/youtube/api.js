// src/lib/youtube/api.js
import axios from 'axios'
import { getValidAccessToken } from './oauth'

const YOUTUBE_API_KEY = process.env.YOUTUBE_API_KEY
const YOUTUBE_API_BASE = 'https://www.googleapis.com/youtube/v3'

if (!YOUTUBE_API_KEY) {
  console.warn('‚ö†Ô∏è YOUTUBE_API_KEY is not set in environment variables')
}

/**
 * Extract video ID from various YouTube URL formats
 */
export function extractVideoId(url) {
  const patterns = [
    /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})/,
    /^([a-zA-Z0-9_-]{11})$/, // Direct video ID
  ]

  for (const pattern of patterns) {
    const match = url.match(pattern)
    if (match) {
      return match[1]
    }
  }

  return null
}

/**
 * Fetch video captions/subtitles count
 * @param {string} videoId - YouTube video ID
 * @param {string} accessToken - Optional OAuth access token
 * @returns {Promise<Object>} Captions data with count and languages
 */
export async function fetchVideoCaptions(videoId, accessToken = null) {
  try {
    const headers = accessToken 
      ? { Authorization: `Bearer ${accessToken}` }
      : {}
    
    const params = {
      part: 'snippet',
      videoId: videoId,
    }
    
    if (!accessToken) {
      params.key = YOUTUBE_API_KEY
    }

    const response = await axios.get(`${YOUTUBE_API_BASE}/captions`, {
      params,
      headers,
    })

    const items = response.data.items || []
    
    return {
      count: items.length,
      languages: items.map(item => ({
        code: item.snippet.language,
        name: item.snippet.name,
        isAutoGenerated: item.snippet.trackKind === 'asr',
        addedAt: new Date()
      })),
      lastSynced: new Date()
    }
  } catch (error) {
    console.warn('Could not fetch captions:', error.message)
    return {
      count: 0,
      languages: [],
      lastSynced: new Date()
    }
  }
}

/**
 * Fetch video details from YouTube API including subtitles
 * @param {string} videoId - YouTube video ID
 * @param {Object} options - Options for fetching
 * @param {boolean} options.useOAuth - If true, use OAuth token instead of API key
 * @returns {Promise<Object>} Video details with subtitle count
 */
export async function fetchVideoDetails(videoId, options = {}) {
  const { useOAuth = false } = options
  
  try {
    let headers = {}
    let params = {
      part: 'snippet,statistics,contentDetails,status',
      id: videoId,
    }

    // Use OAuth if requested (for private/scheduled videos)
    if (useOAuth) {
      try {
        const accessToken = await getValidAccessToken()
        headers = { Authorization: `Bearer ${accessToken}` }
        console.log('üîê Using OAuth token to fetch video details')
      } catch (authError) {
        console.warn('‚ö†Ô∏è OAuth not available, falling back to API key')
        params.key = YOUTUBE_API_KEY
      }
    } else {
      params.key = YOUTUBE_API_KEY
    }

    const response = await axios.get(`${YOUTUBE_API_BASE}/videos`, {
      params,
      headers,
    })

    if (!response.data.items || response.data.items.length === 0) {
      throw new Error('Video not found. The video might be private, scheduled, or the URL is incorrect.')
    }

    const video = response.data.items[0]
    
    // Check video status
    const privacyStatus = video.status?.privacyStatus
    const uploadStatus = video.status?.uploadStatus
    
    console.log(`üìπ Video status: ${privacyStatus}, Upload: ${uploadStatus}`)

    // Fetch captions/subtitles (only for published videos)
    let captionsData = { count: 0, languages: [], lastSynced: new Date() }
    if (privacyStatus === 'public' || privacyStatus === 'unlisted') {
      const captionToken = useOAuth ? headers.Authorization?.split(' ')[1] : null
      captionsData = await fetchVideoCaptions(videoId, captionToken)
    }
    
    return {
      videoId: video.id,
      title: video.snippet.title,
      description: video.snippet.description,
      thumbnailUrl: video.snippet.thumbnails?.high?.url || video.snippet.thumbnails?.default?.url,
      channelId: video.snippet.channelId,
      channelTitle: video.snippet.channelTitle,
      publishedAt: video.snippet.publishedAt,
      duration: video.contentDetails.duration,
      viewCount: parseInt(video.statistics?.viewCount || 0),
      likeCount: parseInt(video.statistics?.likeCount || 0),
      commentCount: parseInt(video.statistics?.commentCount || 0),
      // Add video status info
      privacyStatus: privacyStatus,
      uploadStatus: uploadStatus,
      isScheduled: privacyStatus === 'private' && video.status.publishAt,
      scheduledPublishTime: video.status.publishAt || null,
      // Add subtitle information
      subtitles: captionsData,
      subtitleCount: captionsData.count,
    }
  } catch (error) {
    console.error('Error fetching video details:', error.message)
    
    // Provide more helpful error messages
    if (error.response?.status === 403) {
      throw new Error('Access denied. For private/scheduled videos, make sure YouTube is connected.')
    } else if (error.response?.status === 404) {
      throw new Error('Video not found. Please check if the video ID is correct.')
    } else if (error.message.includes('not found')) {
      throw new Error(error.message)
    } else {
      throw new Error(`Failed to fetch video details: ${error.message}`)
    }
  }
}

/**
 * Fetch channel details from YouTube API
 * @param {string} channelId - YouTube channel ID
 * @returns {Promise<Object>} Channel details
 */
export async function fetchChannelDetails(channelId) {
  try {
    const response = await axios.get(`${YOUTUBE_API_BASE}/channels`, {
      params: {
        part: 'snippet,statistics,contentDetails',
        id: channelId,
        key: YOUTUBE_API_KEY,
      },
    })

    if (!response.data.items || response.data.items.length === 0) {
      throw new Error('Channel not found')
    }

    const channel = response.data.items[0]
    
    return {
      channelId: channel.id,
      title: channel.snippet.title,
      description: channel.snippet.description,
      customUrl: channel.snippet.customUrl,
      thumbnailUrl: channel.snippet.thumbnails?.high?.url || channel.snippet.thumbnails?.default?.url,
      subscriberCount: parseInt(channel.statistics.subscriberCount || 0),
      videoCount: parseInt(channel.statistics.videoCount || 0),
      viewCount: parseInt(channel.statistics.viewCount || 0),
      publishedAt: channel.snippet.publishedAt,
    }
  } catch (error) {
    console.error('Error fetching channel details:', error.message)
    throw new Error(`Failed to fetch channel details: ${error.message}`)
  }
}

/**
 * Search for videos from a channel
 * @param {string} channelId - YouTube channel ID
 * @param {number} maxResults - Maximum number of results (default: 10)
 * @returns {Promise<Array>} Array of video IDs
 */
export async function searchChannelVideos(channelId, maxResults = 10) {
  try {
    const response = await axios.get(`${YOUTUBE_API_BASE}/search`, {
      params: {
        part: 'id',
        channelId: channelId,
        type: 'video',
        order: 'date',
        maxResults: maxResults,
        key: YOUTUBE_API_KEY,
      },
    })

    return response.data.items.map(item => item.id.videoId)
  } catch (error) {
    console.error('Error searching channel videos:', error.message)
    throw new Error(`Failed to search channel videos: ${error.message}`)
  }
}

/**
 * Convert ISO 8601 duration to readable format
 * @param {string} duration - ISO 8601 duration (e.g., "PT10M30S")
 * @returns {string} Readable duration (e.g., "10:30")
 */
export function formatDuration(duration) {
  const match = duration.match(/PT(\d+H)?(\d+M)?(\d+S)?/)
  
  if (!match) return '0:00'
  
  const hours = (match[1] || '').replace('H', '')
  const minutes = (match[2] || '0M').replace('M', '')
  const seconds = (match[3] || '0S').replace('S', '')
  
  const formatted = []
  if (hours) formatted.push(hours)
  formatted.push(minutes.padStart(2, '0'))
  formatted.push(seconds.padStart(2, '0'))
  
  return formatted.join(':')
}